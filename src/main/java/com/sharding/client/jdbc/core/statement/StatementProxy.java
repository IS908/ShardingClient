package com.sharding.client.jdbc.core.statement;

import com.sharding.client.jdbc.core.connection.ConnectionProxy;
import com.sharding.client.jdbc.util.AttributeHelper4Statement;
import com.sharding.client.jdbc.util.Constants;
import com.sharding.client.router.Router;
import com.sharding.client.router.RouterUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * @Description: // TODO
 * @Auther: kun
 * @Date: 2019-04-02
 */
public class StatementProxy extends BaseDdfStatement implements Statement {
    private static final Logger logger = LoggerFactory.getLogger(StatementProxy.class);

    private final ConnectionProxy connectionProxy;

    private List<ResultSet> currentResultSets;

    private boolean executed = false;

    public StatementProxy(ConnectionProxy connectionProxy) {
        this.connectionProxy = connectionProxy;
        this.currentResultSets = new ArrayList<>();
    }

    private void checkExecuted() {
        if (!executed) {
            throw new RuntimeException("Statement not executed yet!");
        }
    }

    @Override
    public Connection getConnection() throws SQLException {
        return connectionProxy;
    }


    private Connection getDdfConnection() throws SQLException {
        logger.debug("router to DDF!");
        return connectionProxy.getTarget();
    }

    private List<Connection> getShardConnection(RouterUnit routerUnit) throws SQLException {
        List<Connection> connectionList = new ArrayList<>();
        for (String dataNode : routerUnit.getDataNodes()) {
            Connection connection = connectionProxy.getConnection(dataNode);
        }
        return connectionList;
    }

    /**
     * 路由到对应的connection创建statement
     *
     * @param sql
     * @return
     * @throws SQLException
     */
    private Map<String, Statement> genPhysicalStatement(String sql) throws SQLException {

        RouterUnit routerUnit = Router.route(connectionProxy.getDatasource().getSchema(), sql);
        logger.debug("router result: {}", routerUnit);
        if (routerUnit.isFinishedRoute()) {
            for (String dataNode : routerUnit.getDataNodes()) {
                Statement statement = getStatementByDsId(dataNode);
                currentStatementHolder.put(dataNode, statement);
            }
        } else {
            Statement statement = getStatementByDsId(Constants.ddfStatementKey);
            currentStatementHolder.put(Constants.ddfStatementKey, statement);
        }
        return currentStatementHolder;
    }

    private Statement getStatementByDsId(String dsId) throws SQLException {
        Statement statement = statementHolder.get(dsId);
        if (statement == null || statement.isClosed()) {
            Connection connection = connectionProxy.getConnection(dsId);
            statement = connection.createStatement();
            statementHolder.put(dsId, statement);
            AttributeHelper4Statement.setAttributes(statement, getAttributes());
        }
        return statement;
    }

    private void beforeExecute() {
        statementHolder.clear();
    }

    private ResultSet afterQuery() {
        executed = true;
        // TODO：结果集合并
        return null;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        beforeExecute();
        ResultSet resultSet = null;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            resultSet = statement.executeQuery(sql);
            currentResultSets.add(resultSet);
        }
        afterQuery();
        return resultSet;
    }

    private int afterUpdate() {
        executed = true;
        // TODO：结果合并
        return 0;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        beforeExecute();
        int count = 0;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            count += statement.executeUpdate(sql);
        }
        afterUpdate();
        return count;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        beforeExecute();
        int count = 0;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            count += statement.executeUpdate(sql, autoGeneratedKeys);
        }
        afterUpdate();
        return count;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        beforeExecute();
        int count = 0;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            count += statement.executeUpdate(sql, columnIndexes);
        }
        afterUpdate();
        return count;
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        beforeExecute();
        int count = 0;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            count += statement.executeUpdate(sql, columnNames);
        }
        afterUpdate();
        return count;
    }

    private boolean afterExecute() {
        this.executed = true;
        // TODO：结果整合
        return false;
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        beforeExecute();
        boolean result = true;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            result &= statement.execute(sql);
        }
        afterExecute();
        return result;
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        beforeExecute();
        boolean result = true;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            result &= statement.execute(sql, autoGeneratedKeys);
        }
        afterExecute();
        return result;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        beforeExecute();
        boolean result = true;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            result &= statement.execute(sql, columnIndexes);
        }
        afterExecute();
        return result;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        beforeExecute();
        boolean result = true;
        for (Statement statement : genPhysicalStatement(sql).values()) {
            result &= statement.execute(sql, columnNames);
        }
        afterExecute();
        return result;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        checkExecuted();
        if (currentStatementHolder.size() > 0) {
            // todo:
            return null;
        }
        return null;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        checkExecuted();
        if (currentStatementHolder.size() > 0) {
            // todo:
            return 0;
        }
        return 0;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        checkExecuted();
        if (currentStatementHolder.size() > 0) {
            // todo:
            return false;
        }
        return false;
    }
}
